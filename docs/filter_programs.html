<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>paroxython.filter_programs API documentation</title>
<meta name="description" content="Evolve a set of selected programs and a set of taxons representing the imparted knowledge …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cse.google.com/cse.js?cx=017837193012385208679:pey8ky8gdqw"></script>
<style>.gsc-control-cse {padding:0 !important;margin-top:1em}</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
<style>.homelink{display:block}.homelink:hover{color:inherit}.homelink img{margin:auto;margin-bottom:.3em}</style>
<link rel="canonical" href="https://pdoc3.github.io/pdoc/doc/paroxython/filter_programs.html">
<link rel="icon" href="https://pdoc.github.io/pdoc/logo.png">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>paroxython.filter_programs</code></h1>
</header>
<section id="section-intro">
<p>Evolve a set of selected programs and a set of taxons representing the imparted knowledge.</p>
<h2 id="description">Description</h2>
<p>Initially, all programs in the database are selected, and the imparted knowledge is empty.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As the filter evolves, the former set can only shrink, and the latter only increase.</p>
</div>
<p>The class stores the state of these two sets and provides a collection of operators to be
applied on them during the execution of the pipeline (see <code><a title="paroxython.recommend_programs" href="recommend_programs.html">paroxython.recommend_programs</a></code>).</p>
<p>TODO</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/filter_programs.py#L0-L482" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">from collections import Counter as counter
from collections import defaultdict
from itertools import permutations, product
from typing import Counter, Dict, Iterator, List, Tuple

import regex  # type: ignore

from .goodies import print_warning
from .normalize_predicate import normalize_predicate
from .user_types import (
    JsonDatabase,
    Operation,
    Predicate,
    ProgramInfos,
    ProgramName,
    ProgramNameSet,
    ProgramToPrograms,
    TaxonInfos,
    TaxonName,
    TaxonNameSet,
    TaxonsPoorSpans,
)

__pdoc__ = {
    &#34;ProgramFilter.__init__&#34;: True,
    &#34;ProgramFilter&#34;: &#34;&#34;,
    &#34;ProgramFilter._iterate_on_spans&#34;: True,
}


class ProgramFilter:

    # Initialization of the filter

    def __init__(self, db: JsonDatabase) -&gt; None:
        self.define_shortcuts(db)
        self.init_filter_state()
        self.add_imported_taxons()

    def define_shortcuts(self, db: JsonDatabase) -&gt; None:
        self.db_programs: ProgramInfos = db[&#34;programs&#34;]
        self.db_taxons: TaxonInfos = db[&#34;taxons&#34;]
        self.db_importations: ProgramToPrograms = db[&#34;importations&#34;]
        self.db_exportations: ProgramToPrograms = db[&#34;exportations&#34;]

    def init_filter_state(self) -&gt; None:
        self.imparted_knowledge: TaxonNameSet = set()
        self.selected_programs: ProgramNameSet = set(self.db_programs)

    def add_imported_taxons(self) -&gt; None:
        for (exporter, importers) in self.db_exportations.items():
            exported_taxons = list(self.db_programs[exporter][&#34;taxons&#34;])
            for exported_taxon in exported_taxons:
                if exported_taxon.startswith(&#34;metadata/&#34;):
                    continue
                for importer in importers:
                    importer_taxons = self.db_programs[importer][&#34;taxons&#34;]
                    if exported_taxon not in importer_taxons:
                        importer_taxons[exported_taxon] = []

    # Get the set of taxon names or program names matching the given pattern.

    def get_taxons_from_taxon_pattern(self, pattern: str) -&gt; TaxonNameSet:
        match = regex.compile(fr&#34;{pattern}\b&#34;).match
        result: TaxonNameSet = set(filter(match, self.db_taxons))
        if not result:
            print_warning(f&#34;the pattern &#39;{pattern}&#39; doesn&#39;t match any existing taxon.&#34;)
        return result

    def get_programs_from_program_pattern(self, pattern: str) -&gt; ProgramNameSet:
        match = regex.compile(fr&#34;{pattern}&#34;).match
        result: ProgramNameSet = set(filter(match, self.db_programs))
        if not result:
            print_warning(f&#34;the pattern &#39;{pattern}&#39; doesn&#39;t match any existing program.&#34;)
        return result

    # Select programs from the taxons they feature, and vice versa.

    def taxons_of_programs(self, programs: ProgramNameSet, follow: bool = False) -&gt; TaxonNameSet:
        taxons: TaxonNameSet = set()
        for program in programs:
            if program in self.db_programs:
                for (taxon, spans) in self.db_programs[program][&#34;taxons&#34;].items():
                    if spans or follow:
                        # Either the taxon is featured directly or the imports must be followed.
                        taxons.add(taxon)
        return taxons

    def programs_of_taxons(self, taxons: TaxonNameSet, follow: bool = False) -&gt; ProgramNameSet:
        programs: ProgramNameSet = set()
        for taxon in taxons:
            programs.update(self.db_taxons.get(taxon, []))
        if follow:
            for program in list(programs):
                programs.update(self.db_exportations[program])
        return programs

    # Deal with semantic triples of the form (taxon_pattern_1, taxon_pattern_2, predicate)

    @staticmethod
    def _iterate_on_spans(
        # fmt: off
        spans: TaxonsPoorSpans,
        taxons_1: TaxonNameSet,
        taxons_2: TaxonNameSet
        # fmt: on
    ) -&gt; Iterator:
        for (taxon_1, taxon_2) in product(taxons_1, taxons_2):
            if taxon_1 in spans and taxon_2 in spans:
                if taxon_1 == taxon_2:  # exclude diagonal from iteration
                    yield from permutations(spans[taxon_1], 2)
                else:
                    yield from product(spans[taxon_1], spans[taxon_2])

    def programs_of_triple(
        # fmt: off
        self,
        taxon_pattern_1: str,
        predicate: Predicate,
        taxon_pattern_2: str,
        # fmt: on
    ) -&gt; ProgramNameSet:
        taxons_1 = self.get_taxons_from_taxon_pattern(taxon_pattern_1)
        taxons_2 = self.get_taxons_from_taxon_pattern(taxon_pattern_2)
        programs_1 = self.programs_of_taxons(taxons_1)
        programs_2 = self.programs_of_taxons(taxons_2)
        result: ProgramNameSet = set()
        for program in programs_1 &amp; programs_2:  # for each program featuring both taxon sets
            spans = self.db_programs[program][&#34;taxons&#34;]
            for (span_1, span_2) in self._iterate_on_spans(spans, taxons_1, taxons_2):
                if predicate(span_1, span_2):
                    result.add(program)
                    break
        return result

    def programs_of_negated_triple(
        # fmt: off
        self,
        taxon_pattern_1: str,
        predicate: Predicate,
        taxon_pattern_2: str,
        # fmt: on
    ) -&gt; ProgramNameSet:
        taxons_1 = self.get_taxons_from_taxon_pattern(taxon_pattern_1)
        taxons_2 = self.get_taxons_from_taxon_pattern(taxon_pattern_2)
        programs_1 = self.programs_of_taxons(taxons_1)
        programs_2 = self.programs_of_taxons(taxons_2)
        result: ProgramNameSet = programs_1  # by default, keep all programs featuring taxon_1
        for program in programs_1 &amp; programs_2:  # for each program featuring both taxon sets
            spans = self.db_programs[program][&#34;taxons&#34;]
            exists_span_2_satisfying_predicate: Dict[Tuple, bool] = defaultdict(bool)
            for (span_1, span_2) in self._iterate_on_spans(spans, taxons_1, taxons_2):
                exists_span_2_satisfying_predicate[tuple(span_1)] |= predicate(span_1, span_2)
            if all(exists_span_2_satisfying_predicate.values()):
                # for any span_1, there is at least one span_2 such that predicate(span_1, span_2)
                result.remove(program)
        return result

    # Update the state of the filter by applying set operations with the given programs.

    def exclude_programs(self, programs: ProgramNameSet, follow: bool) -&gt; None:
        self.selected_programs.difference_update(programs)
        if follow:
            for program in programs:
                self.selected_programs.difference_update(self.db_exportations.get(program, {}))

    def include_programs(self, programs: ProgramNameSet) -&gt; None:
        self.selected_programs.intersection_update(programs)

    # Update the state of the imparted knowledge.

    def impart_taxons(self, taxons: TaxonNameSet) -&gt; None:
        for taxon in taxons:
            edges = taxon.split(&#34;/&#34;)
            for i in range(len(edges)):
                prefix = &#34;/&#34;.join(edges[: i + 1])
                self.imparted_knowledge.add(TaxonName(prefix))

    # Dispatch the update to one of the three above methods

    def update_filter(
        # fmt: off
        self,
        operation: Operation,
        patterns: List[str],
        i: int,
        any_or_all=&#34;any&#34;
        # fmt: on
    ) -&gt; None:
        new_taxons: TaxonNameSet = set()
        new_programs: ProgramNameSet = set()
        pattern_count_by_program: Counter[ProgramName] = counter()
        for pattern in patterns:
            taxons: TaxonNameSet = set()
            programs: ProgramNameSet = set()
            if isinstance(pattern, str):
                if pattern.endswith(&#34;.py&#34;):
                    programs = self.get_programs_from_program_pattern(pattern)
                    taxons = self.taxons_of_programs(programs, operation == &#34;exclude&#34;)
                else:
                    taxons = self.get_taxons_from_taxon_pattern(pattern)
                    if operation != &#34;impart&#34;:
                        programs = self.programs_of_taxons(taxons, operation == &#34;exclude&#34;)
            elif isinstance(pattern, (list, tuple)) and len(pattern) == 3:
                if operation == &#34;impart&#34;:
                    print_warning(f&#34;operation {i} pattern &#39;{pattern}&#39; is ignored (imparted).&#34;)
                    continue
                (pattern_1, raw_predicate, pattern_2) = pattern
                (predicate, negated) = normalize_predicate(raw_predicate)
                f = self.programs_of_negated_triple if negated else self.programs_of_triple
                programs = f(pattern_1, predicate, pattern_2)
            else:
                print_warning(f&#34;operation {i} pattern &#39;{pattern}&#39; is ignored (malformed).&#34;)
            new_taxons.update(taxons)
            new_programs.update(programs)
            pattern_count_by_program.update(programs)
        if any_or_all == &#34;all&#34;:
            new_programs.difference_update(
                program
                for (program, count) in pattern_count_by_program.items()
                if len(patterns) != count
            )
        if operation == &#34;include&#34;:
            self.include_programs(new_programs)
        elif operation == &#34;exclude&#34;:
            self.exclude_programs(new_programs, follow=True)
        elif operation == &#34;impart&#34;:
            self.exclude_programs(new_programs, follow=False)
            self.impart_taxons(new_taxons)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="paroxython.filter_programs.ProgramFilter"><code class="flex name class">
<span>class <span class="ident">ProgramFilter</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/filter_programs.py#L45-L483" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">class ProgramFilter:

    # Initialization of the filter

    def __init__(self, db: JsonDatabase) -&gt; None:
        self.define_shortcuts(db)
        self.init_filter_state()
        self.add_imported_taxons()

    def define_shortcuts(self, db: JsonDatabase) -&gt; None:
        self.db_programs: ProgramInfos = db[&#34;programs&#34;]
        self.db_taxons: TaxonInfos = db[&#34;taxons&#34;]
        self.db_importations: ProgramToPrograms = db[&#34;importations&#34;]
        self.db_exportations: ProgramToPrograms = db[&#34;exportations&#34;]

    def init_filter_state(self) -&gt; None:
        self.imparted_knowledge: TaxonNameSet = set()
        self.selected_programs: ProgramNameSet = set(self.db_programs)

    def add_imported_taxons(self) -&gt; None:
        for (exporter, importers) in self.db_exportations.items():
            exported_taxons = list(self.db_programs[exporter][&#34;taxons&#34;])
            for exported_taxon in exported_taxons:
                if exported_taxon.startswith(&#34;metadata/&#34;):
                    continue
                for importer in importers:
                    importer_taxons = self.db_programs[importer][&#34;taxons&#34;]
                    if exported_taxon not in importer_taxons:
                        importer_taxons[exported_taxon] = []

    # Get the set of taxon names or program names matching the given pattern.

    def get_taxons_from_taxon_pattern(self, pattern: str) -&gt; TaxonNameSet:
        match = regex.compile(fr&#34;{pattern}\b&#34;).match
        result: TaxonNameSet = set(filter(match, self.db_taxons))
        if not result:
            print_warning(f&#34;the pattern &#39;{pattern}&#39; doesn&#39;t match any existing taxon.&#34;)
        return result

    def get_programs_from_program_pattern(self, pattern: str) -&gt; ProgramNameSet:
        match = regex.compile(fr&#34;{pattern}&#34;).match
        result: ProgramNameSet = set(filter(match, self.db_programs))
        if not result:
            print_warning(f&#34;the pattern &#39;{pattern}&#39; doesn&#39;t match any existing program.&#34;)
        return result

    # Select programs from the taxons they feature, and vice versa.

    def taxons_of_programs(self, programs: ProgramNameSet, follow: bool = False) -&gt; TaxonNameSet:
        taxons: TaxonNameSet = set()
        for program in programs:
            if program in self.db_programs:
                for (taxon, spans) in self.db_programs[program][&#34;taxons&#34;].items():
                    if spans or follow:
                        # Either the taxon is featured directly or the imports must be followed.
                        taxons.add(taxon)
        return taxons

    def programs_of_taxons(self, taxons: TaxonNameSet, follow: bool = False) -&gt; ProgramNameSet:
        programs: ProgramNameSet = set()
        for taxon in taxons:
            programs.update(self.db_taxons.get(taxon, []))
        if follow:
            for program in list(programs):
                programs.update(self.db_exportations[program])
        return programs

    # Deal with semantic triples of the form (taxon_pattern_1, taxon_pattern_2, predicate)

    @staticmethod
    def _iterate_on_spans(
        # fmt: off
        spans: TaxonsPoorSpans,
        taxons_1: TaxonNameSet,
        taxons_2: TaxonNameSet
        # fmt: on
    ) -&gt; Iterator:
        for (taxon_1, taxon_2) in product(taxons_1, taxons_2):
            if taxon_1 in spans and taxon_2 in spans:
                if taxon_1 == taxon_2:  # exclude diagonal from iteration
                    yield from permutations(spans[taxon_1], 2)
                else:
                    yield from product(spans[taxon_1], spans[taxon_2])

    def programs_of_triple(
        # fmt: off
        self,
        taxon_pattern_1: str,
        predicate: Predicate,
        taxon_pattern_2: str,
        # fmt: on
    ) -&gt; ProgramNameSet:
        taxons_1 = self.get_taxons_from_taxon_pattern(taxon_pattern_1)
        taxons_2 = self.get_taxons_from_taxon_pattern(taxon_pattern_2)
        programs_1 = self.programs_of_taxons(taxons_1)
        programs_2 = self.programs_of_taxons(taxons_2)
        result: ProgramNameSet = set()
        for program in programs_1 &amp; programs_2:  # for each program featuring both taxon sets
            spans = self.db_programs[program][&#34;taxons&#34;]
            for (span_1, span_2) in self._iterate_on_spans(spans, taxons_1, taxons_2):
                if predicate(span_1, span_2):
                    result.add(program)
                    break
        return result

    def programs_of_negated_triple(
        # fmt: off
        self,
        taxon_pattern_1: str,
        predicate: Predicate,
        taxon_pattern_2: str,
        # fmt: on
    ) -&gt; ProgramNameSet:
        taxons_1 = self.get_taxons_from_taxon_pattern(taxon_pattern_1)
        taxons_2 = self.get_taxons_from_taxon_pattern(taxon_pattern_2)
        programs_1 = self.programs_of_taxons(taxons_1)
        programs_2 = self.programs_of_taxons(taxons_2)
        result: ProgramNameSet = programs_1  # by default, keep all programs featuring taxon_1
        for program in programs_1 &amp; programs_2:  # for each program featuring both taxon sets
            spans = self.db_programs[program][&#34;taxons&#34;]
            exists_span_2_satisfying_predicate: Dict[Tuple, bool] = defaultdict(bool)
            for (span_1, span_2) in self._iterate_on_spans(spans, taxons_1, taxons_2):
                exists_span_2_satisfying_predicate[tuple(span_1)] |= predicate(span_1, span_2)
            if all(exists_span_2_satisfying_predicate.values()):
                # for any span_1, there is at least one span_2 such that predicate(span_1, span_2)
                result.remove(program)
        return result

    # Update the state of the filter by applying set operations with the given programs.

    def exclude_programs(self, programs: ProgramNameSet, follow: bool) -&gt; None:
        self.selected_programs.difference_update(programs)
        if follow:
            for program in programs:
                self.selected_programs.difference_update(self.db_exportations.get(program, {}))

    def include_programs(self, programs: ProgramNameSet) -&gt; None:
        self.selected_programs.intersection_update(programs)

    # Update the state of the imparted knowledge.

    def impart_taxons(self, taxons: TaxonNameSet) -&gt; None:
        for taxon in taxons:
            edges = taxon.split(&#34;/&#34;)
            for i in range(len(edges)):
                prefix = &#34;/&#34;.join(edges[: i + 1])
                self.imparted_knowledge.add(TaxonName(prefix))

    # Dispatch the update to one of the three above methods

    def update_filter(
        # fmt: off
        self,
        operation: Operation,
        patterns: List[str],
        i: int,
        any_or_all=&#34;any&#34;
        # fmt: on
    ) -&gt; None:
        new_taxons: TaxonNameSet = set()
        new_programs: ProgramNameSet = set()
        pattern_count_by_program: Counter[ProgramName] = counter()
        for pattern in patterns:
            taxons: TaxonNameSet = set()
            programs: ProgramNameSet = set()
            if isinstance(pattern, str):
                if pattern.endswith(&#34;.py&#34;):
                    programs = self.get_programs_from_program_pattern(pattern)
                    taxons = self.taxons_of_programs(programs, operation == &#34;exclude&#34;)
                else:
                    taxons = self.get_taxons_from_taxon_pattern(pattern)
                    if operation != &#34;impart&#34;:
                        programs = self.programs_of_taxons(taxons, operation == &#34;exclude&#34;)
            elif isinstance(pattern, (list, tuple)) and len(pattern) == 3:
                if operation == &#34;impart&#34;:
                    print_warning(f&#34;operation {i} pattern &#39;{pattern}&#39; is ignored (imparted).&#34;)
                    continue
                (pattern_1, raw_predicate, pattern_2) = pattern
                (predicate, negated) = normalize_predicate(raw_predicate)
                f = self.programs_of_negated_triple if negated else self.programs_of_triple
                programs = f(pattern_1, predicate, pattern_2)
            else:
                print_warning(f&#34;operation {i} pattern &#39;{pattern}&#39; is ignored (malformed).&#34;)
            new_taxons.update(taxons)
            new_programs.update(programs)
            pattern_count_by_program.update(programs)
        if any_or_all == &#34;all&#34;:
            new_programs.difference_update(
                program
                for (program, count) in pattern_count_by_program.items()
                if len(patterns) != count
            )
        if operation == &#34;include&#34;:
            self.include_programs(new_programs)
        elif operation == &#34;exclude&#34;:
            self.exclude_programs(new_programs, follow=True)
        elif operation == &#34;impart&#34;:
            self.exclude_programs(new_programs, follow=False)
            self.impart_taxons(new_taxons)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="paroxython.filter_programs.ProgramFilter._iterate_on_spans"><code class="name flex">
<span>def <span class="ident">_iterate_on_spans</span></span>(<span>spans: Dict[TaxonName, List[Tuple[int, int]]], taxons_1: Set[TaxonName], taxons_2: Set[TaxonName]) ‑> Iterator</span>
</code></dt>
<dd>
<div class="desc"><p>Generate all relevant couples of spans for the given “subject” and ”object” taxons.</p>
<h2 id="description">Description</h2>
<p>This private function is invoked by <code><a title="paroxython.filter_programs.ProgramFilter.programs_of_triple" href="#paroxython.filter_programs.ProgramFilter.programs_of_triple">ProgramFilter.programs_of_triple()</a></code> and
<code><a title="paroxython.filter_programs.ProgramFilter.programs_of_negated_triple" href="#paroxython.filter_programs.ProgramFilter.programs_of_negated_triple">ProgramFilter.programs_of_negated_triple()</a></code> to enumerate the couples of spans on which
a condition of the form : “<code>subject_span</code> <code>predicate</code> <code>object_span</code>” will be evaluated.
Initially, such a condition is expressed by the user as: “<code>subject_pattern</code> <code>predicate</code>
<code>object_pattern</code>”. Both patterns may match several taxons and, in a given program, each
taxon can occur on several different or even identical spans. Ultimately, the predicate
expresses a relation between two spans.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>spans</code></strong> :&ensp;<code>TaxonsPoorSpans</code></dt>
<dd>The dictionary of the taxons featured by a certain program,
each taxon being associated with a list of poor spans (“poor” meaning that they
contain no other information than the numbers of the first and last line of a taxon
occurrence).</dd>
<dt><strong><code>taxons_1</code></strong> :&ensp;<code>TaxonNameSet</code></dt>
<dd>The various “subject” taxons of the semantic triple.</dd>
<dt><strong><code>taxons_2</code></strong> :&ensp;<code>TaxonNameSet</code></dt>
<dd>The various “object” taxons of the semantic triple.</dd>
</dl>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>Iterator[PoorSpan]</code></dt>
<dd>Couples of poor spans, in no particular order.</dd>
</dl>
<h2 id="example">Example</h2>
<p>Consider a program featuring taxons <code>t1</code>, <code>t2</code>, <code>t3</code> and <code>t4</code> on the following spans:</p>
<pre><code class="python">&gt;&gt;&gt; spans = {
...      &quot;t1&quot;: [(1, 1), (1, 1), (1, 2)],
...      &quot;t2&quot;: [(2, 3), (1, 2)],
...      &quot;t3&quot;: [(3, 3)],
...      &quot;t4&quot;: [(4, 4)],
... }
</code></pre>
<p>Note that <code>t1</code> occurs twice on span <code>(1, 1)</code>, and that <code>t1</code> and <code>t2</code> have span <code>(1, 2)</code>
in common.</p>
<p>Suppose first that the sets <code>taxons_1</code> and <code>taxons_2</code> have no common taxons. In this
case, the couples of spans on which to check the predicate are obtained by a simple
cross-product, <em>e.g.</em>:</p>
<pre><code class="python">&gt;&gt;&gt; _iterate_on_spans(spans, {&quot;t1&quot;, &quot;t2&quot;}, {&quot;t3&quot;, &quot;t4&quot;})
((1, 1), (3, 3))  # t1 (1) ⨉ t3
((1, 1), (3, 3))  # t1 (2) ⨉ t3
((1, 2), (3, 3))  # t1 (3) ⨉ t3
((1, 1), (4, 4))  # t1 (1) ⨉ t4
((1, 1), (4, 4))  # t1 (2) ⨉ t4
((1, 2), (4, 4))  # t1 (3) ⨉ t4
((2, 3), (3, 3))  # t2 (1) ⨉ t3
((1, 2), (3, 3))  # t2 (2) ⨉ t3
((2, 3), (4, 4))  # t2 (1) ⨉ t4
((1, 2), (4, 4))  # t2 (2) ⨉ t4
</code></pre>
<p>Suppose now that the sets <code>taxons_1</code> and <code>taxons_2</code> have <code>t1</code> in common. In that case,
we must suppress the diagonal of the cross-product, which not only carries zero useful
information, but will make certain conditions fail. For instance, if we seek to include
all the programs <em>not</em> featuring two multiplications on the same line, the condition
will be something like: “no multiplication is featured on the same line than another
one”. Keeping the diagonal would add “or itself“ to the previous condition. Since any
taxon is obviously featured on the same line than itself, no program would satisfy the
condition.</p>
<p>In the example below, note which lines are suppressed, and which are kept (particularly
for <code>((1, 1), (1, 1))</code>):</p>
<pre><code class="python">&gt;&gt;&gt; _iterate_on_spans(spans, {&quot;t1&quot;, &quot;t2&quot;}, {&quot;t1&quot;, &quot;t3&quot;})
# ((1, 1), (1, 1))  # t1 (1) ⨉ t1 (1) (not generated)
  ((1, 1), (1, 1))  # t1 (1) ⨉ t1 (2)
  ((1, 1), (1, 2))  # t1 (1) ⨉ t1 (3)
  ((1, 1), (1, 1))  # t1 (2) ⨉ t1 (1)
# ((1, 1), (1, 1))  # t1 (2) ⨉ t1 (2) (not generated)
  ((1, 1), (1, 2))  # t1 (2) ⨉ t1 (3)
  ((1, 2), (1, 1))  # t1 (3) ⨉ t1 (1)
  ((1, 2), (1, 1))  # t1 (3) ⨉ t1 (2)
# ((1, 2), (1, 2))  # t1 (3) ⨉ t1 (3) (not generated)
  ((1, 1), (3, 3))  # t1 (1) ⨉ t3
  ((1, 1), (3, 3))  # t1 (2) ⨉ t3
  ((1, 2), (3, 3))  # t1 (3) ⨉ t3
  ((2, 3), (1, 1))  # t2 (1) ⨉ t1 (1)
  ((2, 3), (1, 1))  # t2 (1) ⨉ t1 (2)
  ((2, 3), (1, 2))  # t2 (1) ⨉ t1 (3)
  ((1, 2), (1, 1))  # t2 (2) ⨉ t1 (1)
  ((1, 2), (1, 1))  # t2 (2) ⨉ t1 (2)
  ((1, 2), (1, 2))  # t2 (2) ⨉ t1 (3)
  ((2, 3), (3, 3))  # t2 (1) x t3
  ((1, 2), (3, 3))  # t2 (2) x t3
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/filter_programs.py#L195-L293" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">@staticmethod
def _iterate_on_spans(
    # fmt: off
    spans: TaxonsPoorSpans,
    taxons_1: TaxonNameSet,
    taxons_2: TaxonNameSet
    # fmt: on
) -&gt; Iterator:
    for (taxon_1, taxon_2) in product(taxons_1, taxons_2):
        if taxon_1 in spans and taxon_2 in spans:
            if taxon_1 == taxon_2:  # exclude diagonal from iteration
                yield from permutations(spans[taxon_1], 2)
            else:
                yield from product(spans[taxon_1], spans[taxon_2])</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="paroxython.filter_programs.ProgramFilter.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self, db: JsonDatabase) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Call <code>define_shortcuts()</code>,
<code>init_filter_state()</code> and <code>add_imported_taxons()</code> (below).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/filter_programs.py#L49-L53" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def __init__(self, db: JsonDatabase) -&gt; None:
    self.define_shortcuts(db)
    self.init_filter_state()
    self.add_imported_taxons()</code></pre>
</details>
</dd>
<dt id="paroxython.filter_programs.ProgramFilter.define_shortcuts"><code class="name flex">
<span>def <span class="ident">define_shortcuts</span></span>(<span>self, db: JsonDatabase) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Define some attributes that point directly to the main parts of the database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/filter_programs.py#L55-L60" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def define_shortcuts(self, db: JsonDatabase) -&gt; None:
    self.db_programs: ProgramInfos = db[&#34;programs&#34;]
    self.db_taxons: TaxonInfos = db[&#34;taxons&#34;]
    self.db_importations: ProgramToPrograms = db[&#34;importations&#34;]
    self.db_exportations: ProgramToPrograms = db[&#34;exportations&#34;]</code></pre>
</details>
</dd>
<dt id="paroxython.filter_programs.ProgramFilter.init_filter_state"><code class="name flex">
<span>def <span class="ident">init_filter_state</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Select all programs and define the imparted knowledge as empty.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/filter_programs.py#L62-L65" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def init_filter_state(self) -&gt; None:
    self.imparted_knowledge: TaxonNameSet = set()
    self.selected_programs: ProgramNameSet = set(self.db_programs)</code></pre>
</details>
</dd>
<dt id="paroxython.filter_programs.ProgramFilter.add_imported_taxons"><code class="name flex">
<span>def <span class="ident">add_imported_taxons</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Copy under each program the taxons it featured by importation.</p>
<h2 id="description">Description</h2>
<p>Initially, the JSON database stores under each program all the taxons it features
<em>directly</em>, for instance:</p>
<pre><code>{
    &quot;programs&quot;: {
        ...
        &quot;fizzbuzz.py&quot;: {
            ...
            &quot;taxons&quot;: {
                &quot;call/function/builtin/print&quot;: [[4,4],[6,6],[8,8],[10,10]],
                &quot;call/function/builtin/range&quot;: [[2,2]],
                &quot;flow/conditional&quot;: [[3,10],[5,10],[7,10]],
                ...
</code></pre>
<p>For performance and readability reasons, it is useful to complete such a dictionary
with the taxons which are featured <em>indirectly</em>, namely those featured by the imported
programs. For instance, assuming that <code>fizzbuzz.py</code> imports <code>collatz.py</code>, we must
copy the taxons featured by the latter, but not by the former program, namely:</p>
<pre><code>                &quot;operator/arithmetic/multiplication&quot;: [],
                &quot;subroutine/argument/arg&quot;: [],
                &quot;subroutine/procedure&quot;: [],
                ...
</code></pre>
<h2 id="notes">Notes</h2>
<ul>
<li>The spans of the imported taxons are not copied, but replaced by an empty list (it is
enough to know that a certain taxon is only featured by an imported program, not on
which lines of which program).</li>
<li>All imported taxons starting with <code>"metadata/"</code> are by convention excluded from the
copy.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/filter_programs.py#L67-L113" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def add_imported_taxons(self) -&gt; None:
    for (exporter, importers) in self.db_exportations.items():
        exported_taxons = list(self.db_programs[exporter][&#34;taxons&#34;])
        for exported_taxon in exported_taxons:
            if exported_taxon.startswith(&#34;metadata/&#34;):
                continue
            for importer in importers:
                importer_taxons = self.db_programs[importer][&#34;taxons&#34;]
                if exported_taxon not in importer_taxons:
                    importer_taxons[exported_taxon] = []</code></pre>
</details>
</dd>
<dt id="paroxython.filter_programs.ProgramFilter.get_taxons_from_taxon_pattern"><code class="name flex">
<span>def <span class="ident">get_taxons_from_taxon_pattern</span></span>(<span>self, pattern: str) ‑> Set[TaxonName]</span>
</code></dt>
<dd>
<div class="desc"><p>Find all the existing taxons matching the given regular expression pattern.</p>
<h2 id="note">Note</h2>
<p>All taxons are searched, not just the ones featured by a selected program.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/filter_programs.py#L117-L127" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def get_taxons_from_taxon_pattern(self, pattern: str) -&gt; TaxonNameSet:
    match = regex.compile(fr&#34;{pattern}\b&#34;).match
    result: TaxonNameSet = set(filter(match, self.db_taxons))
    if not result:
        print_warning(f&#34;the pattern &#39;{pattern}&#39; doesn&#39;t match any existing taxon.&#34;)
    return result</code></pre>
</details>
</dd>
<dt id="paroxython.filter_programs.ProgramFilter.get_programs_from_program_pattern"><code class="name flex">
<span>def <span class="ident">get_programs_from_program_pattern</span></span>(<span>self, pattern: str) ‑> Set[ProgramName]</span>
</code></dt>
<dd>
<div class="desc"><p>Find all the existing programs matching the given regular expression pattern.</p>
<h2 id="note">Note</h2>
<p>All programs are searched, not just the selected ones.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/filter_programs.py#L129-L139" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def get_programs_from_program_pattern(self, pattern: str) -&gt; ProgramNameSet:
    match = regex.compile(fr&#34;{pattern}&#34;).match
    result: ProgramNameSet = set(filter(match, self.db_programs))
    if not result:
        print_warning(f&#34;the pattern &#39;{pattern}&#39; doesn&#39;t match any existing program.&#34;)
    return result</code></pre>
</details>
</dd>
<dt id="paroxython.filter_programs.ProgramFilter.taxons_of_programs"><code class="name flex">
<span>def <span class="ident">taxons_of_programs</span></span>(<span>self, programs: Set[ProgramName], follow: bool = False) ‑> Set[TaxonName]</span>
</code></dt>
<dd>
<div class="desc"><p>Return the taxons featured (or optionally imported) by any given program.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>programs</code></strong> :&ensp;<code>ProgramNameSet</code></dt>
<dd>Program names. The non-existing ones are silently ignored.</dd>
<dt><strong><code>follow</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If true, include the taxons featured by the imported programs.
Defaults to <code>False</code>.</dd>
</dl>
<h2 id="example">Example</h2>
<p>Let <code>p1</code>, <code>p2</code>, <code>p3</code> be three programs, with <code>p3</code> importing <code>p2</code>, and <code>p2</code> importing
<code>p1</code>. Let <code>t</code> be a taxon featured by <code>p1</code> only. Then:</p>
<pre><code class="python">&gt;&gt;&gt; t in taxons_of_programs({p1})
True
&gt;&gt;&gt; t in taxons_of_programs({p2})
False
&gt;&gt;&gt; t in taxons_of_programs({p3}, follow=True)
True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/filter_programs.py#L143-L168" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def taxons_of_programs(self, programs: ProgramNameSet, follow: bool = False) -&gt; TaxonNameSet:
    taxons: TaxonNameSet = set()
    for program in programs:
        if program in self.db_programs:
            for (taxon, spans) in self.db_programs[program][&#34;taxons&#34;].items():
                if spans or follow:
                    # Either the taxon is featured directly or the imports must be followed.
                    taxons.add(taxon)
    return taxons</code></pre>
</details>
</dd>
<dt id="paroxython.filter_programs.ProgramFilter.programs_of_taxons"><code class="name flex">
<span>def <span class="ident">programs_of_taxons</span></span>(<span>self, taxons: Set[TaxonName], follow: bool = False) ‑> Set[ProgramName]</span>
</code></dt>
<dd>
<div class="desc"><p>Return the programs featuring (or optionally importing) any given taxon.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>taxons</code></strong> :&ensp;<code>TaxonNameSet</code></dt>
<dd>Taxon names. The non-existing ones are silently ignored.</dd>
<dt><strong><code>follow</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If true, include the programs importing at least one program
featuring at least one taxon. Defaults to <code>False</code>.</dd>
</dl>
<h2 id="example">Example</h2>
<p>With <code>p1</code>, <code>p2</code>, <code>p3</code> and <code>t</code> as in the example of <code><a title="paroxython.filter_programs.ProgramFilter.taxons_of_programs" href="#paroxython.filter_programs.ProgramFilter.taxons_of_programs">ProgramFilter.taxons_of_programs()</a></code>:</p>
<pre><code class="python">&gt;&gt;&gt; programs_of_taxons({t})
{p1}
&gt;&gt;&gt; programs_of_taxons({t}, follow=True)
{p1, p2, p3}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/filter_programs.py#L170-L191" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def programs_of_taxons(self, taxons: TaxonNameSet, follow: bool = False) -&gt; ProgramNameSet:
    programs: ProgramNameSet = set()
    for taxon in taxons:
        programs.update(self.db_taxons.get(taxon, []))
    if follow:
        for program in list(programs):
            programs.update(self.db_exportations[program])
    return programs</code></pre>
</details>
</dd>
<dt id="paroxython.filter_programs.ProgramFilter.programs_of_triple"><code class="name flex">
<span>def <span class="ident">programs_of_triple</span></span>(<span>self, taxon_pattern_1: str, predicate: Callable[[int, int], bool], taxon_pattern_2: str) ‑> Set[ProgramName]</span>
</code></dt>
<dd>
<div class="desc"><p>Return the programs where two given taxons satisfy a given predicate.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>taxon_pattern_1</code></strong> :&ensp;<code>str</code></dt>
<dd>A regular expression pattern matching the <strong>subject</strong> of the
semantic triple.</dd>
<dt><strong><code>predicate</code></strong> :&ensp;<code>Predicate</code></dt>
<dd>the predicate of the semantic triple, expressed in positive
form.</dd>
<dt><strong><code>taxon_pattern_2</code></strong> :&ensp;<code>str</code></dt>
<dd>A regular expression pattern matching the <strong>object</strong> of the
semantic triple.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ProgramNameSet</code></dt>
<dd>The programs featuring at least one span <code>s_1</code> of <code>taxon_1</code> and one
span <code>s_2</code> of <code>taxon_2</code> for which <code>predicate(s_1, s_2)</code> is verified.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/filter_programs.py#L295-L328" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def programs_of_triple(
    # fmt: off
    self,
    taxon_pattern_1: str,
    predicate: Predicate,
    taxon_pattern_2: str,
    # fmt: on
) -&gt; ProgramNameSet:
    taxons_1 = self.get_taxons_from_taxon_pattern(taxon_pattern_1)
    taxons_2 = self.get_taxons_from_taxon_pattern(taxon_pattern_2)
    programs_1 = self.programs_of_taxons(taxons_1)
    programs_2 = self.programs_of_taxons(taxons_2)
    result: ProgramNameSet = set()
    for program in programs_1 &amp; programs_2:  # for each program featuring both taxon sets
        spans = self.db_programs[program][&#34;taxons&#34;]
        for (span_1, span_2) in self._iterate_on_spans(spans, taxons_1, taxons_2):
            if predicate(span_1, span_2):
                result.add(program)
                break
    return result</code></pre>
</details>
</dd>
<dt id="paroxython.filter_programs.ProgramFilter.programs_of_negated_triple"><code class="name flex">
<span>def <span class="ident">programs_of_negated_triple</span></span>(<span>self, taxon_pattern_1: str, predicate: Callable[[int, int], bool], taxon_pattern_2: str) ‑> Set[ProgramName]</span>
</code></dt>
<dd>
<div class="desc"><p>Return the programs where at least one occurrence of two taxons violates the predicate.</p>
<h2 id="args">Args</h2>
<p>The same arguments as <code><a title="paroxython.filter_programs.ProgramFilter.programs_of_triple" href="#paroxython.filter_programs.ProgramFilter.programs_of_triple">ProgramFilter.programs_of_triple()</a></code>, including the fact that the
predicate is expressed in <strong>positive</strong> form.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ProgramNameSet</code></dt>
<dd>The programs such that, for each span <code>s_1</code> of <code>taxon_1</code>, there
exists no span <code>s_2</code> of <code>taxon_2</code> for which <code>predicate(s_1, s_2)</code> is verified.</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Returns also all programs featuring at least one <code>taxon_1</code>, but no <code>taxon_2</code>. Indeed,
suppose the user wants to exclude all the programs featuring at least one tuple which
is not used in a parallel assignment. Let us call the two types of tuples “ordinary”
and “parallel”. This function will return a set of programs where:</p>
<ul>
<li>there is at least one tuple, but no parallel tuple (<em>i.e.</em>, all tuples are ordinary);</li>
<li>or there is at least one ordinary tuple (<em>i.e.</em>, one tuple which is not parallel).</li>
</ul>
<p>Excluding these two sets keeps only the programs where:</p>
<ul>
<li>there is no tuple;</li>
<li>or all tuples are parallel.</li>
</ul>
<p>If, in the first stage, the function did not return the programs featuring at least one
tuple, but no parallel tuple, the second stage would exclude all the programs featuring
no tuple, which would certainly not correspond to the user's intention.</p>
</div>
<h2 id="examples">Examples</h2>
<p>If the predicate is <code>"taxon_1 not inside taxon_2"</code>, any program consisting in:</p>
<ul>
<li><code>"taxon_2{taxon_1}"</code><sup id="fnref:braces"><a class="footnote-ref" href="#fn:braces" rel="footnote">1</a></sup> is rejected;</li>
<li><code>"taxon_1"</code> is <strong>accepted</strong> (although there is no <code>taxon_2</code>);</li>
<li><code>"taxon_2"</code> is <strong>rejected</strong> (no <code>taxon_1</code>);</li>
<li><code>"taxon_1{taxon_2}"</code> is accepted;</li>
<li><code>"taxon_1 taxon_2{taxon_1}"</code> is accepted (there exists a couple (<code>s_1</code>, <code>s_2</code>) such
that <code>taxon_1</code> is not inside <code>taxon_2</code>);</li>
<li><code>"taxon_1 taxon_2{taxon_1} taxon_2{}"</code> is accepted.</li>
</ul>
<p>If the predicate is <code>"taxon_2 not contains taxon_1"</code> (sic), any program consisting in:</p>
<ul>
<li><code>"taxon_2{taxon_1}"</code> is rejected;</li>
<li><code>"taxon_1"</code> is <strong>rejected</strong> (no <code>taxon_2</code>);</li>
<li><code>"taxon_2"</code> is <strong>accepted</strong> (although there is no <code>taxon_1</code>);</li>
<li><code>"taxon_1{taxon_2}"</code> is accepted;</li>
<li><code>"taxon_1 taxon_2{taxon_1}"</code> is accepted (there exists a couple (<code>s_1</code>, <code>s_2</code>) such
that <code>taxon_2</code> does not contain <code>taxon_1</code>);</li>
<li><code>"taxon_1 taxon_2{taxon_1} taxon_2{}"</code> is accepted.</li>
</ul>
<p>Note that, due to the rule explained in the warning above, <code>"taxon_1 not inside taxon_2"</code>
is not strictly equivalent to <code>"taxon_2 not contains taxon_1"</code>.</p>
<div class="footnote">
<hr>
<ol>
<li id="fn:braces">
<p>In these examples, the braces are used to denote the fact that the span of a
certain taxon is included in that of another taxon.&#160;<a class="footnote-backref" href="#fnref:braces" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/filter_programs.py#L330-L407" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def programs_of_negated_triple(
    # fmt: off
    self,
    taxon_pattern_1: str,
    predicate: Predicate,
    taxon_pattern_2: str,
    # fmt: on
) -&gt; ProgramNameSet:
    taxons_1 = self.get_taxons_from_taxon_pattern(taxon_pattern_1)
    taxons_2 = self.get_taxons_from_taxon_pattern(taxon_pattern_2)
    programs_1 = self.programs_of_taxons(taxons_1)
    programs_2 = self.programs_of_taxons(taxons_2)
    result: ProgramNameSet = programs_1  # by default, keep all programs featuring taxon_1
    for program in programs_1 &amp; programs_2:  # for each program featuring both taxon sets
        spans = self.db_programs[program][&#34;taxons&#34;]
        exists_span_2_satisfying_predicate: Dict[Tuple, bool] = defaultdict(bool)
        for (span_1, span_2) in self._iterate_on_spans(spans, taxons_1, taxons_2):
            exists_span_2_satisfying_predicate[tuple(span_1)] |= predicate(span_1, span_2)
        if all(exists_span_2_satisfying_predicate.values()):
            # for any span_1, there is at least one span_2 such that predicate(span_1, span_2)
            result.remove(program)
    return result</code></pre>
</details>
</dd>
<dt id="paroxython.filter_programs.ProgramFilter.exclude_programs"><code class="name flex">
<span>def <span class="ident">exclude_programs</span></span>(<span>self, programs: Set[ProgramName], follow: bool) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Deselect the programs found among the given ones and optionally importing them.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/filter_programs.py#L411-L416" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def exclude_programs(self, programs: ProgramNameSet, follow: bool) -&gt; None:
    self.selected_programs.difference_update(programs)
    if follow:
        for program in programs:
            self.selected_programs.difference_update(self.db_exportations.get(program, {}))</code></pre>
</details>
</dd>
<dt id="paroxython.filter_programs.ProgramFilter.include_programs"><code class="name flex">
<span>def <span class="ident">include_programs</span></span>(<span>self, programs: Set[ProgramName]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Deselect the programs not found among the given ones.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/filter_programs.py#L418-L420" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def include_programs(self, programs: ProgramNameSet) -&gt; None:
    self.selected_programs.intersection_update(programs)</code></pre>
</details>
</dd>
<dt id="paroxython.filter_programs.ProgramFilter.impart_taxons"><code class="name flex">
<span>def <span class="ident">impart_taxons</span></span>(<span>self, taxons: Set[TaxonName]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Enrich the imparted knowledge with all the prefixes of the given taxons.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/filter_programs.py#L424-L430" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def impart_taxons(self, taxons: TaxonNameSet) -&gt; None:
    for taxon in taxons:
        edges = taxon.split(&#34;/&#34;)
        for i in range(len(edges)):
            prefix = &#34;/&#34;.join(edges[: i + 1])
            self.imparted_knowledge.add(TaxonName(prefix))</code></pre>
</details>
</dd>
<dt id="paroxython.filter_programs.ProgramFilter.update_filter"><code class="name flex">
<span>def <span class="ident">update_filter</span></span>(<span>self, operation: Operation, patterns: List[str], i: int, any_or_all='any') ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Update the selected programs and optionally impart the associated taxons.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/laowantong/paroxython/blob/master/paroxython/filter_programs.py#L434-L483" class="git-link">Browse GitHub</a>
</summary>
<pre><code class="python">def update_filter(
    # fmt: off
    self,
    operation: Operation,
    patterns: List[str],
    i: int,
    any_or_all=&#34;any&#34;
    # fmt: on
) -&gt; None:
    new_taxons: TaxonNameSet = set()
    new_programs: ProgramNameSet = set()
    pattern_count_by_program: Counter[ProgramName] = counter()
    for pattern in patterns:
        taxons: TaxonNameSet = set()
        programs: ProgramNameSet = set()
        if isinstance(pattern, str):
            if pattern.endswith(&#34;.py&#34;):
                programs = self.get_programs_from_program_pattern(pattern)
                taxons = self.taxons_of_programs(programs, operation == &#34;exclude&#34;)
            else:
                taxons = self.get_taxons_from_taxon_pattern(pattern)
                if operation != &#34;impart&#34;:
                    programs = self.programs_of_taxons(taxons, operation == &#34;exclude&#34;)
        elif isinstance(pattern, (list, tuple)) and len(pattern) == 3:
            if operation == &#34;impart&#34;:
                print_warning(f&#34;operation {i} pattern &#39;{pattern}&#39; is ignored (imparted).&#34;)
                continue
            (pattern_1, raw_predicate, pattern_2) = pattern
            (predicate, negated) = normalize_predicate(raw_predicate)
            f = self.programs_of_negated_triple if negated else self.programs_of_triple
            programs = f(pattern_1, predicate, pattern_2)
        else:
            print_warning(f&#34;operation {i} pattern &#39;{pattern}&#39; is ignored (malformed).&#34;)
        new_taxons.update(taxons)
        new_programs.update(programs)
        pattern_count_by_program.update(programs)
    if any_or_all == &#34;all&#34;:
        new_programs.difference_update(
            program
            for (program, count) in pattern_count_by_program.items()
            if len(patterns) != count
        )
    if operation == &#34;include&#34;:
        self.include_programs(new_programs)
    elif operation == &#34;exclude&#34;:
        self.exclude_programs(new_programs, follow=True)
    elif operation == &#34;impart&#34;:
        self.exclude_programs(new_programs, follow=False)
        self.impart_taxons(new_taxons)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="Paroxython Home" href="index.html">
<img src="https://laowantong.github.io/paroxython/resources/logo.png" alt="Paroxython logo">
</a>
</header>
<div class="gcse-search" style="height: 70px"
data-as_oq="site:laowantong/paroxython.github.io inurl:github.com/laowantong/paroxython"
data-gaCategoryParameter="paroxython.filter_programs">
</div>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="paroxython" href="index.html">paroxython</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="paroxython.filter_programs.ProgramFilter" href="#paroxython.filter_programs.ProgramFilter">ProgramFilter</a></code></h4>
<ul class="">
<li><code><a title="paroxython.filter_programs.ProgramFilter._iterate_on_spans" href="#paroxython.filter_programs.ProgramFilter._iterate_on_spans">_iterate_on_spans</a></code></li>
<li><code><a title="paroxython.filter_programs.ProgramFilter.__init__" href="#paroxython.filter_programs.ProgramFilter.__init__">__init__</a></code></li>
<li><code><a title="paroxython.filter_programs.ProgramFilter.define_shortcuts" href="#paroxython.filter_programs.ProgramFilter.define_shortcuts">define_shortcuts</a></code></li>
<li><code><a title="paroxython.filter_programs.ProgramFilter.init_filter_state" href="#paroxython.filter_programs.ProgramFilter.init_filter_state">init_filter_state</a></code></li>
<li><code><a title="paroxython.filter_programs.ProgramFilter.add_imported_taxons" href="#paroxython.filter_programs.ProgramFilter.add_imported_taxons">add_imported_taxons</a></code></li>
<li><code><a title="paroxython.filter_programs.ProgramFilter.get_taxons_from_taxon_pattern" href="#paroxython.filter_programs.ProgramFilter.get_taxons_from_taxon_pattern">get_taxons_from_taxon_pattern</a></code></li>
<li><code><a title="paroxython.filter_programs.ProgramFilter.get_programs_from_program_pattern" href="#paroxython.filter_programs.ProgramFilter.get_programs_from_program_pattern">get_programs_from_program_pattern</a></code></li>
<li><code><a title="paroxython.filter_programs.ProgramFilter.taxons_of_programs" href="#paroxython.filter_programs.ProgramFilter.taxons_of_programs">taxons_of_programs</a></code></li>
<li><code><a title="paroxython.filter_programs.ProgramFilter.programs_of_taxons" href="#paroxython.filter_programs.ProgramFilter.programs_of_taxons">programs_of_taxons</a></code></li>
<li><code><a title="paroxython.filter_programs.ProgramFilter.programs_of_triple" href="#paroxython.filter_programs.ProgramFilter.programs_of_triple">programs_of_triple</a></code></li>
<li><code><a title="paroxython.filter_programs.ProgramFilter.programs_of_negated_triple" href="#paroxython.filter_programs.ProgramFilter.programs_of_negated_triple">programs_of_negated_triple</a></code></li>
<li><code><a title="paroxython.filter_programs.ProgramFilter.exclude_programs" href="#paroxython.filter_programs.ProgramFilter.exclude_programs">exclude_programs</a></code></li>
<li><code><a title="paroxython.filter_programs.ProgramFilter.include_programs" href="#paroxython.filter_programs.ProgramFilter.include_programs">include_programs</a></code></li>
<li><code><a title="paroxython.filter_programs.ProgramFilter.impart_taxons" href="#paroxython.filter_programs.ProgramFilter.impart_taxons">impart_taxons</a></code></li>
<li><code><a title="paroxython.filter_programs.ProgramFilter.update_filter" href="#paroxython.filter_programs.ProgramFilter.update_filter">update_filter</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>